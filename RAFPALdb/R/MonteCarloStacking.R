#' 
#'
#' 
#' @param user .
#' @param pass .
#' @param host .
#' @param NREP Number of scenarios to generate (default 50,000).
#' @keywords connection
#' @export
#' @examples
#' Pella.init=Interpolation.init(sites=c("PEL-1-1","PEL-1-4a"),variable="ReconTemp",time.range=c(0,50000),time.resol=100,NREP=1000,Citation_Keys=c("Lim_etal_2016","Lim_etal_2016"))


{
    dat=Interpolation.init(sites=c("PEL-1-1","PEL-1-4a"),variable="ReconAI",time.range=c(0,50000),time.resol=100,NREP=5000,Citation_Keys=c("Lim_etal_2016","Lim_etal_2016"))
    dat=removeSample(dat,21,"PEL-1-1")
    dat$ReconUncer[["PEL-1-4a"]]=dat$ReconUncer[["PEL-1-4a"]][1:21,]
    dat=MonteCarloInterpolation(dat,exportData=TRUE)
    dat=MonteCarloCentring(dat,"PEL-1-1",c("PEL-1-4a",100,1200))
    dat=MonteCarloStacking(dat,exportData=TRUE)
}

Interpolation.init <- function(sites,variable,time.range,time.resol,NREP,Citation_Keys=FALSE){
    X.OUT=seq(time.range[1],time.range[2],time.resol)      
    dat=list("Recon"=list(),"ReconUncer"=list(),"ReconUncerXX"=list(),"ReconMC"=list(),"Chrono"=list(),"ChronoUncer"=list(),"ChronoUncerXX"=list(),"ChronoMC"=list(),"Interp"=list(),"Interp.opt"=list(),"Interp.opt.weight"=list(),"Stack"=matrix(0,ncol=length(X.OUT),nrow=9),"StackMC"=matrix(0,ncol=length(X.OUT),nrow=NREP),"Sites"=sites,"XX"=X.OUT,"Variable"=variable,"NREP"=NREP,"N.NA"=NREP/100,"CENTRING"=sapply(sites,function(x) return(list(0))),"COL"=sapply(sites,function(x) return(sample(colors(),1))))

    for(i in 1:length(dat$Sites)){
        recon=getData(Record_Name=sites[i],Citation_Key=Citation_Keys[i],Proxy=variable,Proxy.Uncer=TRUE,Chronology=TRUE,Chrono.Uncer=TRUE)
        dat$Recon[[sites[i]]]=recon$Data$Data
        dat$ReconUncer[[sites[i]]]=recon$Data$Uncertainties
        dat$ReconUncer[[sites[i]]][which(is.na(dat$ReconUncer[[sites[i]]]))]=0
        dat$ReconUncerXX[[sites[i]]]=as.numeric(colnames(recon$Data$Uncertainties))
        dat$Chrono[[sites[i]]]=recon$Chronology$Chronology
        
        cc=as.numeric(recon$Chronology$Uncertainties[,1])
        for(j in 2:ncol(recon$Chronology$Uncertainties)){ cc=cbind(cc,as.numeric(recon$Chronology$Uncertainties[,j]))  }
        cc[which(is.na(cc))]=0
        dat$ChronoUncer[[sites[i]]]=cc
        dat$ChronoUncerXX[[sites[i]]]=as.numeric(colnames(recon$Chronology$Uncertainties))

        dat$ReconMC[[sites[i]]]=matrix(0,ncol=dat$NREP,nrow=length(dat$Recon[[sites[i]]]))
        dat$ChronoMC[[sites[i]]]=matrix(0,ncol=dat$NREP,nrow=length(dat$Chrono[[sites[i]]]))
        dat$Interp[[sites[i]]]=matrix(0,ncol=dat$NREP,nrow=length(dat$XX))
    }
    
    # dat$Stack = opt,avg(opt),nsites,30inf,30sup,50inf,50sup,80inf,80sup
    return(dat)
}


#' Remove a sample from a Monte-Carlo object.
#'
#' Remove a sample from a Monte-Carlo object.
#' @param dat The classic Monte-Carlo object generated by Interpolation.init().
#' @param n ID of the sample(s) to remove.
#' @param site Name of the Record to remove samples from.
#' @keywords Monte-Carlo
#' @export
#' @examples
#' dat=removeSample(dat,21,"PEL-1-1")
 
removeSample <- function(dat,n,site){
    dat$Recon[[site]]=dat$Recon[[site]][-n]
    dat$ReconUncer[[site]]=dat$ReconUncer[[site]][-n,]
    dat$Chrono[[site]]=dat$Chrono[[site]][-n]
    dat$ChronoUncer[[site]]=dat$ChronoUncer[[site]][-n,]
    dat$ReconMC[[site]]=matrix(0,ncol=dat$NREP,nrow=length(dat$Recon[[site]]))
    dat$ChronoMC[[site]]=matrix(0,ncol=dat$NREP,nrow=length(dat$Chrono[[site]]))
    return(dat)
}


#' Interpolate individually each reconstruction.
#'
#' Interpolate individually each reconstruction.
#' @param dat The classic Monte-Carlo object generated by Interpolation.init().
#' @param exportData Boolean (default FALSE) to save the individual interpolations.
#' @param saveData Folder where to save the outputs (in the working folder by default).
#' @keywords Monte-Carlo
#' @export
#' @examples
#' Connect(user="root",pass="root123")

MonteCarloInterpolation <- function(dat,exportData=FALSE,saveData=getwd()){
    cat("Interpolation\n")
    for(s in dat$Sites){
        cat("\t",s,"\t0.. ")

        tot=nrow(dat$ReconUncer[[s]])+nrow(dat$ChronoUncer[[s]])+dat$NREP
        pos=.10

        for(i in 1:nrow(dat$ChronoUncer[[s]])){
            dat$ChronoMC[[s]][i,]=sample(dat$ChronoUncerXX[[s]],size=dat$NREP,replace=TRUE,prob=dat$ChronoUncer[[s]][i,])
            if(i/tot>pos){  cat(100*pos,ifelse(pos==1,"%.\n",".. "))  ;  pos=pos+0.1  }
        }
        
        for(i in 1:nrow(dat$ReconUncer[[s]])){
            dat$ReconMC[[s]][i,]=sample(dat$ReconUncerXX[[s]],size=dat$NREP,replace=TRUE,prob=dat$ReconUncer[[s]][i,])
            if((i+nrow(dat$ChronoUncer[[s]]))/tot>pos){  cat(100*pos,ifelse(pos==1,"%.\n",".. "))  ;  pos=pos+0.1 ; print(pos) }
        }
        
        oo=apply(dat$ChronoMC[[s]],2,order)
        for(i in 1:dat$NREP){
            dat$Interp[[s]][,i]=approx(dat$ChronoMC[[s]][oo[,i],i],dat$ReconMC[[s]][oo[,i],i],xout=dat$XX)$y
            if((i+nrow(dat$ChronoUncer[[s]])+nrow(dat$ReconUncer[[s]]))/tot>pos){  cat(100*pos,ifelse((i+nrow(dat$ChronoUncer[[s]])+nrow(dat$ReconUncer[[s]]))==tot,"%.\n",".. "))  ;  pos=pos+0.1 }
        }

        dat$Interp.opt[[s]]=apply(dat$Interp[[s]],1,function(x){w=which(!is.na(x)) ; if(length(w)>dat$N.NA){ d=density(x[w]) ; return(d$x[which.max(d$y)])}else{return(NA)}})
        dat$Interp.opt.weight[[s]]=apply(dat$Interp[[s]],1,function(x){w=which(!is.na(x)) ; if(length(w)>dat$N.NA){ return(length(w)/dat$NREP) }else{return(0)}})
    }
    if(exportData) exportMonteCarloInterpolation(dat,saveData)
    return(dat)
}

dat=MonteCarloInterpolation(dat,exportData=FALSE)

#' Export interpolated reconstructions into .csv and .pdf files.
#'
#' Export interpolated reconstructions into .csv and .pdf files.
#' @param dat The classic Monte-Carlo object generated by Interpolation.init().
#' @param saveData Folder where to save the outputs (in the working folder by default).
#' @keywords Monte-Carlo, Plot
#' @export
#' @examples
#' exportMonteCarloInterpolation()

exportMonteCarloInterpolation <- function(dat,saveData=getwd()){
    cat("Exporting\n")
    for(s in dat$Sites){
        cat("\t",s,"\t0 ..")
        
        tot=10/9*3*nrow(dat$Interp[[s]])
        pos=.10

        # 30% uncertainties
        interv50=c(0,0)
        for(i in 1:nrow(dat$Interp[[s]])){
            w.na=which(!is.na(dat$Interp[[s]][i,]))
            if(length(w.na)>dat$N.NA){
                d=density(dat$Interp[[s]][i,w.na])
                pdfvar=.getPDFSubset(d$x,d$y,thres=.3)
                w=which(pdfvar>0)
                interv50=rbind(interv50,c(d$x[w[1]],d$x[w[length(w)]]))
            }else{
                interv50=rbind(interv50,c(NA,NA))
            }
            if(i/tot>pos){  cat(100*pos,".. ")  ;  pos=pos+0.1  }

        }
        interv50=interv50[-1,]
        output=cbind(XX=dat$XX,Recon=dat$Interp.opt[[s]],AVG=.mov.avg(dat$Interp.opt[[s]]),apply(interv50,2,.mov.avg))
        
        # 50% uncertainties
        interv50=c(0,0)
        for(i in 1:nrow(dat$Interp[[s]])){
            w.na=which(!is.na(dat$Interp[[s]][i,]))
            if(length(w.na)>dat$N.NA){
                d=density(dat$Interp[[s]][i,w.na])
                pdfvar=.getPDFSubset(d$x,d$y,thres=.5)
                w=which(pdfvar>0)
                interv50=rbind(interv50,c(d$x[w[1]],d$x[w[length(w)]]))
            }else{
                interv50=rbind(interv50,c(NA,NA))
            }
            if((i+nrow(dat$Interp[[s]]))/tot>pos){  cat(100*pos,".. ")  ;  pos=pos+0.1  }

        }
        interv50=interv50[-1,]
        output=cbind(output,apply(interv50,2,.mov.avg)) 
        
        # 80% uncertainties
        interv50=c(0,0)
        for(i in 1:nrow(dat$Interp[[s]])){
            w.na=which(!is.na(dat$Interp[[s]][i,]))
            if(length(w.na)>dat$N.NA){
                d=density(dat$Interp[[s]][i,w.na])
                pdfvar=.getPDFSubset(d$x,d$y,thres=.8)
                w=which(pdfvar>0)
                interv50=rbind(interv50,c(d$x[w[1]],d$x[w[length(w)]]))
            }else{
                interv50=rbind(interv50,c(NA,NA))
            }
            if((i+2*nrow(dat$Interp[[s]]))/tot>pos){  cat(100*pos,".. ")  ;  pos=pos+0.1  }

        }
        interv50=interv50[-1,]
        output=cbind(output,apply(interv50,2,.mov.avg))
        colnames(output)=c("Age",dat$Variable,paste(dat$Variable,"smoothed"),"30%min","30%max","50%min","50%max","80%min","80%max")
        write.csv(output,paste(saveData,"/",s,"_",dat$Variable,"_MonteCarlo.csv",sep=""))
        
        
        pdf(paste(saveData,"/",s,"_",dat$Variable,"_MonteCarlo.pdf",sep=""),width=3.54,height=3.54)  ;  {
            par(mar=c(2.1,2,1.1,1),mgp=c(1,0.4,-0.5))
            plot(0,0,type='n',xlim=range(dat$XX[which(!is.na(dat$Interp.opt[[s]]))]),ylim=range(c(output[,9],output[,8],dat$Recon[[s]]),na.rm=TRUE),frame=FALSE,axes=FALSE,main=paste(s,dat$Variable,"interpolated"),xlab="Age",ylab=dat$Variable,cex.main=0.8,font.main=1)
          
            w.na=which(is.na(output[,3]))
            polygon(cbind(c(dat$XX[-w.na],rev(dat$XX[-w.na])),c(output[-w.na,9],rev(output[-w.na,8]))),col=makeTransparent('cornflowerblue',alpha=0.2),border=makeTransparent('cornflowerblue',alpha=0.2))
            polygon(cbind(c(dat$XX[-w.na],rev(dat$XX[-w.na])),c(output[-w.na,7],rev(output[-w.na,6]))),col=makeTransparent('cornflowerblue',alpha=0.5),border=makeTransparent('cornflowerblue',alpha=0.5))
            polygon(cbind(c(dat$XX[-w.na],rev(dat$XX[-w.na])),c(output[-w.na,5],rev(output[-w.na,4]))),col=makeTransparent('cornflowerblue',alpha=0.8),border=makeTransparent('cornflowerblue',alpha=0.8))
            points(dat$XX,.mov.avg(dat$Interp.opt[[s]]),type='l',lwd=0.5,col='white')
            points(dat$Chrono[[s]],dat$Recon[[s]],pch='.',cex=3,col='black')
            
            axis(1,at=range(dat$XX),labels=c("",""),lwd.ticks=0)
            axis(1,lwd=1,lwd.ticks=1,cex.axis=0.8)
            axis(2,at=range(c(output[,9],output[,8],dat$Recon[[s]]),na.rm=TRUE),labels=c("",""),lwd.ticks=0)
            axis(2,lwd=1,lwd.ticks=1,cex.axis=0.8)
        }  ;  dev.off()
        cat("100%.\n")
    }
    
}


#' Automatically calculates an optimum centring value for the stacking.
#'
#' Automatically calculates an optimum centring value for the stacking.
#' @param dat The classic Monte-Carlo object generated by Interpolation.init().
#' @param ref String that indicates the sequence of reference.
#' @param overlap Vector that indicates for each site the period to consider for the overlap, e.g. c("site1",0,10000,"site2",3000,11000,"site3",350,8000)
#' @keywords Monte-Carlo
#' @export
#' @examples
#' 

MonteCarloCentring <- function(dat,ref,overlap){
    overlap=matrix(overlap,ncol=3,byrow=TRUE)  ;  rownames(overlap)=overlap[,1]
    #centring=list()
    for(s in dat$Sites){
        #centring[[s]]=0
        if(s != ref){
            w=which(dat$XX <= overlap[s,3] & dat$XX >= overlap[s,2])
            if(length(w)>0)  dat$CENTRING[[s]]=mean(dat$Interp.opt[[s]][w]-dat$Interp.opt[[ref]][w],na.rm=TRUE)
        }
    }
    return(dat)
}


#' Perform the Monte-Carlo stacking.
#'
#' Perform the Monte-Carlo stacking.
#' @param dat The classic Monte-Carlo object generated by Interpolation.init().
#' @param centring A vector of values to center data. Using the output of MonteCarloCentring() is recommended.
#' @param exportData Boolean (default FALSE) to save the individual interpolations.
#' @param saveData Folder where to save the outputs (in the working folder by default).
#' @keywords Monte-Carlo
#' @export
#' @examples
#' Connect(user="root",pass="root123")

MonteCarloStacking <- function(dat,exportData=FALSE,saveData=getwd()){
    #if(is.vector(centring)){  centring=sapply(centring,list)  ;  names(centring)=dat$Sites  }
    nsites=c()

    pos=0.1
    tot=length(dat$XX)*1.1
    
    cat("Stacking\t0.. ")
    for(x in 1:length(dat$XX)){
        nsite=0
        tot.weight=0
        for(s in dat$Sites){
            w=which(!is.na(dat$Interp[[s]][x,]))
            if(length(w)>dat$N.NA){
                nsite=nsite+1
                d=density(dat$Interp[[s]][x,w])
                dat$StackMC[,x]=dat$StackMC[,x]+sample(d$x-dat$CENTRING[[s]],size=dat$NREP,replace=TRUE,prob=d$y)*dat$Interp.opt.weight[[s]][x]
                tot.weight=tot.weight+dat$Interp.opt.weight[[s]][x]
            }
        }
        dat$StackMC[,x]=dat$StackMC[,x]/tot.weight
        nsites=c(nsites,nsite)
        if(x/tot>pos){  cat(100*pos,".. ")  ;  pos=pos+0.1 }
    }

    dat$Stack[1,]=apply(dat$StackMC,2,function(x){d=density(x) ; return(d$x[which.max(d$y)])})
    dat$Stack[2,]=.mov.avg(dat$Stack[1,])
    dat$Stack[3,]=nsites
    dat$Stack[4:5,]=apply(dat$StackMC[1:length(dat$XX),],2,function(x){d=density(x) ; sub=.getPDFSubset(d$x,d$y,0.3) ; w=which(sub>0) ; return(d$x[c(min(w),max(w))])})
    dat$Stack[6:7,]=apply(dat$StackMC[1:length(dat$XX),],2,function(x){d=density(x) ; sub=.getPDFSubset(d$x,d$y,0.5) ; w=which(sub>0) ; return(d$x[c(min(w),max(w))])})
    dat$Stack[8:9,]=apply(dat$StackMC[1:length(dat$XX),],2,function(x){d=density(x) ; sub=.getPDFSubset(d$x,d$y,0.8) ; w=which(sub>0) ; return(d$x[c(min(w),max(w))])})

    cat("100%.\n")

    if(exportData) exportMonteCarloStacking(dat,saveData)
    return(dat)
}

#' Export stacked reconstructions into .csv and .pdf files.
#'
#' Export stacked reconstructions into .csv and .pdf files.
#' @param dat The classic Monte-Carlo object generated by Interpolation.init().
#' @param saveData Folder where to save the outputs (in the working folder by default).
#' @keywords Monte-Carlo, Plot
#' @export
#' @examples
#' exportMonteCarloInterpolation()

exportMonteCarloStacking <- function(dat,saveData=getwd(),vline=seq(min(dat$XX),max(dat$XX),length.out=11),XLAB="Age"){
    pdf(paste(saveData,"/",dat$Variable,"_SpaghettiPlot.pdf",sep=""),width=3.54,height=5)  ;  {
        layout(matrix(c(1,2),ncol=1),height=c(5,1))

        # Spaghetti
        YRANGE=range(c(dat$Stack[6,],dat$Stack[7,],unlist(dat$Interp.opt)),na.rm=TRUE)
        par(mar=c(0,2,0,2),mgp=c(1,0.4,-0.5))
        plot(0,0,type='n',xlim=range(dat$XX),ylim=YRANGE,frame=FALSE,axes=FALSE,main="",xlab="",ylab=dat$Variable)
        axis(2,at=YRANGE,labels=c("",""),lwd.ticks=0)
        axis(2,lwd=1,lwd.ticks=1,cex.axis=0.8)

        for(i in vline){    abline(v=i,lty=2,lwd=0.3)    }
        
        w=which(!is.na(dat$Stack[1,]))
        polygon(cbind(c(dat$XX[w],rev(dat$XX[w])),c(dat$Stack[7,w],rev(dat$Stack[6,w]))),col="grey80",border=NA)
        polygon(cbind(c(dat$XX[w],rev(dat$XX[w])),c(dat$Stack[5,w],rev(dat$Stack[4,w]))),col="grey50",border=NA)

        for(s in dat$Sites){    points(dat$XX,dat$Interp.opt[[s]]-dat$CENTRING[[s]],col=dat$COL[[s]],type='l',lwd=0.8)    } # Individual sites
        points(dat$XX,dat$Stack[2,],col="black",lwd=1,type='l') # Stack
        legend("bottomright",legend=dat$Sites,col=unlist(dat$COL),cex=0.8,text.col=unlist(dat$COL),fill=unlist(dat$COL),border=unlist(dat$COL),bg="White")
        
        # Nsites
        par(mar=c(2.1,2,0,2),mgp=c(1,0.4,-0.1))
        plot(0,0,type='n',xlim=range(dat$XX),ylim=c(0,max(dat$Stack[3,],na.rm=TRUE)),frame=FALSE,axes=FALSE,main="",xlab=XLAB,ylab="")
        for(i in vline){    abline(v=i,lty=2,lwd=0.3)    }

        i=1
        while(i<=length(dat$XX)){
            p1=i
            p2=p1+1
            while(dat$Stack[3,][p2]==dat$Stack[3,][p1] & p2 < length(dat$XX)){p2=p2+1}
            rect(dat$XX[p1],0,dat$XX[p2],dat$Stack[3,][p1],col=gray(max(dat$Stack[3,]):1/(2*max(dat$Stack[3,])))[dat$Stack[3,p1]],border=NA)
            i=p2
        }
        axis(1,at=range(dat$XX),labels=c("",""),lwd.ticks=0)
        axis(1,lwd=1,lwd.ticks=1,cex.axis=0.8)
        axis(4,at=range(dat$Stack[3,],na.rm=TRUE),labels=c("",""),lwd.ticks=0)
        axis(4,lwd=1,lwd.ticks=1,cex.axis=0.8)     
    }
    dev.off()
}


#' Interpolate the pdfage to the common scale.
#'
#' Interpolate the pdfage to the common scale.
#' @param dat The column produced by the function 'Bacon.hist.save()' from Bacon().
#' @param xstep The temporal resolution (Default 100yrs).
#' @keywords Monte-Carlo, Chronologies
#' @export
#' @examples
#' 

.rescaleAgeErrors <- function(dat,xstep=100){
    R=c(-xstep,2*xstep)+(range(dat[,seq(1,ncol(dat),2)])%/%xstep)*xstep
    xx=seq(R[1],R[2],xstep)
    
    poids=as.data.frame(matrix(0,ncol=ncol(dat)/2,nrow=length(xx)))
    for(i in seq(1,ncol(dat),2))  poids[,(i-1)/2+1]=approx(dat[,i],dat[,i+1],xx)$y
 
    am.ext=cbind(xx,poids)  ;  colnames(am.ext)=c("depth",sapply(colnames(d)[seq(1,ncol(d),2)],function(x) return(substr(x,2,nchar(x)-4))))
    return(am.ext)
}

#' Extract intervals of probability based on the area under the curve.
#'
#' Extract intervals of probability based on the area under the curve.
#' @param x The gradient.
#' @param y The probability density function.
#' @param thres The threshold (between 0 and 1).
#' @keywords Monte-Carlo, pdf
#' @export
#' @examples
#' 

.getPDFSubset <- function(x,y,thres=.90){
    if(thres<0) thres=0
    if(thres>1) thres=1
    w=which(is.na(y))
    if(length(w)>0)  y[w]=0
    xy=cbind(x,y)
    xy=xy[order(xy[,2],decreasing=TRUE),]
    s=sum(xy[,2])
    xy[,2]=xy[,2]/s
    w=which(cumsum(xy[,2])>thres)
    xy[w,2]=0
    xy=xy[order(xy[,1]),]
    w=which(xy[,2]>0)
    xy[w,2]=xy[w,2]-min(xy[w,2],na.rm=TRUE)
    return(xy[,2]*s)
}
